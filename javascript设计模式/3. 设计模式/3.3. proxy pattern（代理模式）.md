# 定义
==代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。代理模式的核心是当一个客户不方便直接访问一个对象时，==

==可以提供一个替身来访问这个对象，客户实际是直接访问替身对象，替身对象对请求做一些处理之后，在把请求交个对象本体。==

# 代理模式的分类
代理模式根据意图可以分为保护代理、虚拟代理、缓存代理等。
## 保护代理
举个例子，比如很多客户要访问同一个对象，但是需要过滤一下，因为并不是所有的客户都有权限访问，这个时候可以利用代理模式，让所有的客户都访问这个代理对象，在代理对象中可以根据条件进行过滤。
这种代理就是保护代理。

## 虚拟代理
在实际的开发中可能会遇到一些开销很大的操作，这个操作在代理对象中延迟到需要的时候再执行。
这种代理叫做虚拟代理。
## 缓存代理
缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果。
# ==代理的意义==
为了解释代理模式的意义，我们先引入一个面向对象设计的原则——单一职责原则。
> 单一职责原则指的是，就一个类（通常也包括对象和函数等）而言，应该仅有一个引起它变化的原因

面向对象鼓励将行为分布到更细粒度的对象之中。从而变得更加高内聚低耦合。
为了更好的说明代理的意义，我们引入一个例子
## 实现图片预加载
一个虚拟代理的例子
```typescript
var myImage = (function () {
  var imgNode = document.createElement("img");
  document.body.appendChild(imgNode);

  return {
    setSrc: function (src: string) {
      imgNode.src = src;
    },
  };
})();
myImage.setSrc( 'http:// imgcache.qq.com/music/photo/k/000GGDys0yA0Nk.jpg' );
```
上面的代码中没有使用代理模式，在图片加载会有一段时间的空白。
下面使用代理模式优化这段代码
```typescript
// 虚拟代理 (virtual proxy)
function proxy(image: { setSrc: (src: string) => void }) {
  const img = new Image();
  img.onload = function () {
    image.setSrc(img.src);
  };
  return {
    setSrc(src: string) {
      image.setSrc("本地静态资源.svg");
      img.src = src;
    },
  };
}
const proxyImage = proxy(myImage);
proxyImage.setSrc("真实图片url");
```
 通过`virtual proxy`我们将预加载的逻辑封装到代理方法中，没有改变`myImage`对象本身的逻辑，但是通过代理对象给系统添加了新的功能。这是符合开放——封闭原则的。同时我们将设置图片资源和预加载的逻辑抽离到了不同的对象中，这符合单一职责原则。
`proxy`对于`myImage`来说是锦上添花的功能，假如某一天不需要代理了，我们只需要请求对象本体而不是请求代理对象。
# 代理和本体接口的一致性
在客户看来，代理对象和本体是一致的， 代理接手请求的过程对于用户来说是透明的，用户并不清楚代理和本体的区别，这样做有两个好处。

- 用户可以放心地请求代理，他只关心是否能得到想要的结果
- 在任何使用本体的地方都可以替换成使用代理
# 虚拟代理合并http请求
假设下面这个场景，我们有一个列表，每个列表都有个一个checkbox，如下图所示。![image.png](https://cdn.nlark.com/yuque/0/2023/png/12763837/1691384023310-a9a0ee78-1e55-4e1e-a4b4-4aa1f38c956d.png#averageHue=%23eaf0ef&clientId=u26ebd132-9179-4&from=paste&height=335&id=u32df4968&originHeight=670&originWidth=1472&originalType=binary&ratio=2&rotation=0&showTitle=false&size=475813&status=done&style=none&taskId=u4d1de2be-6da2-45f2-923c-a61f50f4e9b&title=&width=736)
每当我们点击checkout的时候就要向后台请求接口。假如我们点击的频率非常高，可预见会造成很大的网络开销了。
这个时候我们就可以使用代理模式来优化，我们可以通过代理函数。在代理函数中，我们可以收集一段时间请求，最后一次行打包发给服务端。
```javascript
var synchronousFile = function( id ){
    console.log( '开始同步文件，id为: ' + id );
};

var proxySynchronousFile = (function(){
    var cache = [],    // 保存一段时间内需要同步的ID
        timer;    // 定时器

     return function( id ){
        cache.push( id );
        if ( timer ){    // 保证不会覆盖已经启动的定时器
            return;
        }

        timer = setTimeout(function(){
            synchronousFile( cache.join( ',' ) );    // 2秒后向本体发送需要同步的ID集合
            clearTimeout( timer );    // 清空定时器
            timer = null;
            cache.length = 0; // 清空ID集合
        }, 2000 );
    }
})();
```
上面的例子中，checkbox会产生一个id数组，我们点击checkbox的时候就会创建一个定时器然后两秒后从数组中获取数据，并打包发给服务端。
# 其他的代理模式

- 防火墙代理：控制网络资源的访问，保护主题不让“坏人”接近。
- 远程代理：为一个对象在不同的地址空间提供局部代表，在Java中，远程代理可以是另一个虚拟机中的对象。
- 保护代理：用于对象应该有不同访问权限的情况。
- 智能引用代理：取代了简单的指针，它在访问对象时执行一些附加操作，比如计算一个对象被引用的次数。
- 写时复制代理：通常用于复制一个庞大对象的情况。写时复制代理延迟了复制的过程，当对象被真正修改时，才对它进行复制操作。写时复制代理是虚拟代理的一种变体，DLL（操作系统中的动态链接库）是其典型运用场景。
# 代理模式的优缺点
## 优点

- 代理模式可以实现封装和解耦，让客户端不需要知道目标对象的具体细节。
- 代理模式可以实现延迟加载，只有当真正需要时才创建目标对象，从而节省资源和提高性能。
- 代理模式可以实现安全性和权限控制，通过代理对象对目标对象的访问进行过滤和检查。
- 代理模式可以实现增强功能，通过代理对象在目标对象的前后添加一些额外的逻辑，例如日志、缓存、事务等。
## 缺点

- 代理模式会增加系统的复杂度和开销，因为需要创建和维护代理对象。
- 代理模式可能会影响系统的响应速度和用户体验，因为代理对象会增加一些额外的处理时间。
- 代理模式可能会造成不一致性和逻辑错误，如果代理对象和目标对象的行为不完全相同或者不同步更新。
# 总结
代理模式有很多小分类，在js中常用的有虚拟代理和缓存代理。我们在实际的开发中通常不用预先设计是否使用代理模式，可以在发现直接访问一个对象不合适时在考虑使用代理模式。


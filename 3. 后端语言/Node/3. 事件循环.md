# 简介

每个阶段都有一个 FIFO 队列来执行回调。虽然每个阶段都是特殊的，但通常情况下，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后执行该阶段队列中的回调，直到队列用尽或最大回调数已执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段，等等。

由于这些操作中的任何一个都可能调度 更多的 操作和由内核排列在轮询阶段被处理的新事件， 且在处理轮询中的事件时，轮询事件可以排队。因此，长时间运行的回调可以允许轮询阶段运行长于计时器的阈值时间。有关详细信息，请参阅 计时器和 轮询 部分。

事件循环图示：

![img](https://raw.githubusercontent.com/yqm1995/pic_bed/master/images/1654681773027-2ad63162-cdbf-414d-9b36-21d323ded668.png)

| 定时器        | 本阶段执行已经被setTimeout()和setinterval()的调度回调函数。  |
| ------------- | ------------------------------------------------------------ |
| 待定回调      | 执行延迟到下一个循环迭代的I/O回调。                          |
| idle，prepare | 进系统内部使用。                                             |
| 轮询          | 检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。 |
| 检测          | 执行setImmediate。                                           |
| 关闭          | 执行一些关闭的回调函数socket.on('close', ...)。              |

# 轮询

1. 计算应该阻塞和轮询 I/O 的时间。
2. 然后，处理 轮询 队列里的事件。

当事件循环进入轮询阶段且没有被调度的计时器时，将发生以下两种情况之一：

1. 如果轮询队列不是空的，事件循环将循环的访问队列并执行，直到队列为空或者达到系统的硬件瓶颈。
2. 如果轮询队列为空会发生两件事：

1. 如果脚本被setImmediate调度，则事件循环将结束轮询阶段，并继续检查阶段以执行那些被调度的脚本。
2. 如果脚本未被setImmediate调度，则事件循环将等待回调被添加到队列中，然后立即执行。

# setImmediate对比setTimeout

如果有注册setImmediate，他会在轮询结束之后的检查阶段执行其中的脚本。

setTimeout会等到达到设置的时间阈值之后放入定时器队列并被事件循环执行。

如果不在I/O事件中注册，则调用的时机是不确定的，因为受到进程性能约束。首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的
进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调，如果准备时间花费小于 1ms，那么就是 setImmediate 回调先执行了。

如果在I/O事件中注册：因为I/O事件会在轮询阶段被检测和执行，当I/O执行结束之后，事件循环会继续执行检测，此时在I/O中被注册的setImmediate会被执行。等到下一个事件循环的定时器阶段才会执行setTimeout。

# process.nextTick对比setImmediate

process.nextTick独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。但是从node11开始，nextTick和microTask会在每个宏任务之后执行，每当执行一个宏任务之后都会去检测nextTick和微任务，并清空任务队列。
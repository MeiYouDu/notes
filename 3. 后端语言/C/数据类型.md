C 语言的每一种数据，都是有类型（type）的，编译器必须知道数据的类型，才能操作数据。所谓“类型”，就是相似的数据所拥有的共同特征，那么一旦知道某个值的数据类型，就能知道该值的特征和操作方式。
基本数据类型有三种：字符（char）、整数（int）和浮点数（float）。复杂的类型都是基于它们构建的。
# 字符类型
字符类型指的是单个字符，类型声明使用`char`关键字。
C语言中声明字符类型必须使用单引号`''`。
在计算机内部，字符类型使用一个字节byte（8位bit）存储。C语言将其当作整数处理，所以字符类型是宽度为一个字节的整数。每个字符都对应个一个整数（ASCII 美国标准信息交互代码），比如`B`对应的整数是`66`。
整数类型在计算机内部的默认范围是不一样的，有些系统默认是`-128`到`127`，另一些是`0`到`255`，不过他们都能覆盖ASCII的字符范围。
只要在字符类型的范围之内，整数与字符是可以互换的，都可以赋值给字符类型的变量。
```c
// 声明的是字符类型，但是赋的值是一个int，C会自动把int转变成字符类型。
char c = 66;
// 等同于
char c = 'B';


// 假如赋值超过int8（取决于操作系统，darwin平台上默认是int8，有的系统可能是Uint8）的范围，会使用二进制补码的形式来处理整型溢出。
char Test = 128;
```

有些字符需要转义字符来打印ASCII定义的无法打印的控制字符。

- `\a`：警报，这会使得终端发出警报声或出现闪烁，或者两者同时发生。
- `\b`：退格键，光标回退一个字符，但不删除字符。
- `\f`：换页符，光标移到下一页。在现代系统上，这已经反映不出来了，行为改成类似于\v。
- `\n`：换行符。
- `\r`：回车符，光标移到同一行的开头。
- `\t`：制表符，光标移到下一个水平制表位，通常是下一个8的倍数。
- `\v`：垂直分隔符，光标移到下一个垂直制表位，通常是下一行的同一列。
- `\0`：null 字符，代表没有内容。注意，这个值不等于数字0。

转义写法还能使用八进制和十六进制表示一个字符。

- `\nn：`字符的八进制写法，`nn`为八进制值。
- `\xnn：`字符的十六进制写法，`nn`为十六进制值。
# 整数类型
整数类型用来表示较大的整数，类型声明使用`int`关键字。
不同的计算机的`int`类型的取值范围是不一样的。比较常见的是使用4个字节（32位）存储一个`int`类型的值，当然也有使用2个字节（16位）和8个字节（64位）来存储一个`int`类型的。

- 16位：-32,768 到 32,767。
- 32位：-2,147,483,648 到 2,147,483,647。
- 64位：-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807。

总来来说就是![](https://cdn.nlark.com/yuque/__latex/2a27b858d97ab7ebce7b0c8a36b394ee.svg#card=math&code=%E4%BB%8E-2%5E%7Bn-1%7D%E5%88%B02%5E%7Bn-1%7D%20-%201&id=lrHfX)。
## 符号和无符号
C语言中使用`signed`关键字表示一个类型带正负号，使用`unsigned`关键字表示没有正负号，只有零和正整数。
默认情况下，C语言中声明`int`类型是带符号的，也就是默认有`signed`，
如果想声明无符号的整数则需要使用`unsigned`。
```c
unsigned int a = 123;
// 等同于
unsigned a = 123;
```
字符类型`char`也可以设置`signed`和`unsigned`。
```c
signed char c; // 范围为 -128 到 127
unsigned char c; // 范围为 0 到 255
```
注意，C 语言规定`char`类型默认是否带有正负号，由当前系统决定。这就是说，`char`不等同于`signed char`，它有可能是`signed char`，也有可能是`unsigned char`。这一点与`int`不同，`int`就是等同于`signed int`。
## 整数的子类型
如果`int`类型使用4个或8个字节表示一个整数，对于小整数，这样做很浪费空间。另一方面，某些场合需要更大的整数，8个字节还不够。为了解决这些问题，C 语言在int类型之外，又提供了三个整数的子类型。这样有利于更精细地限定整数变量的范围，也有利于更好地表达代码的意图。

- short int（简写为short）：占用空间不多于int，一般占用2个字节（整数范围为-32768～32767)。
- long int（简写为long）：占用空间不少于int，至少为4个字节。
- long long int（简写为long long）：占用空间多于long，至少为8个字节。
## 整数类型的极限值
有时候需要查看，当前系统不同整数类型的最大值和最小值，C 语言的头文件`limits.h`提供了相应的常量，比如`SCHAR_MIN`代表`signed char`类型的最小值`-128`，`SCHAR_MAX`代表 `signed char` 类型的最大值127。
为了代码的可移植性，需要知道某种整数类型的极限值时，应该尽量使用这些常量。

- `SCHAR_MIN`，SCHAR_MAX：signed char 的最小值和最大值。
- `SHRT_MIN`，SHRT_MAX：short 的最小值和最大值。
- `INT_MIN`，INT_MAX：int 的最小值和最大值。
- `LONG_MIN`，LONG_MAX：long 的最小值和最大值。
- `LLONG_MIN`，LLONG_MAX：long long 的最小值和最大值。
- `UCHAR_MAX`：unsigned char 的最大值。
- `USHRT_MAX`：unsigned short 的最大值。
- `UINT_MAX`：unsigned int 的最大值。
- `ULONG_MAX`：unsigned long 的最大值。
- `ULLONG_MAX`：unsigned long long 的最大值。
## 整数的进制
C 语言的整数默认都是十进制数，如果要表示八进制数和十六进制数，必须使用专门的表示法。

- 八进制使用0作为前缀，比如`017`、`0377`。
- 十六进制使用`0x`或`0X`作为前缀，比如`0xf`、`0X10`。
- 有些编译器使用`0b`前缀，表示二进制数，但不是标准。
# 浮点数类型
任何有小数点的数值都会被编译器解释为浮点数。所谓“浮点数”就是使用 ![](data:image/svg+xml;utf8,%3Csvg%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20width%3D%226.231ex%22%20height%3D%222.343ex%22%20style%3D%22vertical-align%3A%20-0.338ex%3B%22%20viewBox%3D%220%20-863.1%202682.8%201008.6%22%20role%3D%22img%22%20focusable%3D%22false%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20aria-labelledby%3D%22MathJax-SVG-1-Title%22%3E%0A%3Ctitle%20id%3D%22MathJax-SVG-1-Title%22%3EEquation%3C%2Ftitle%3E%0A%3Cdefs%20aria-hidden%3D%22true%22%3E%0A%3Cpath%20stroke-width%3D%221%22%20id%3D%22E1-MJMATHI-6D%22%20d%3D%22M21%20287Q22%20293%2024%20303T36%20341T56%20388T88%20425T132%20442T175%20435T205%20417T221%20395T229%20376L231%20369Q231%20367%20232%20367L243%20378Q303%20442%20384%20442Q401%20442%20415%20440T441%20433T460%20423T475%20411T485%20398T493%20385T497%20373T500%20364T502%20357L510%20367Q573%20442%20659%20442Q713%20442%20746%20415T780%20336Q780%20285%20742%20178T704%2050Q705%2036%20709%2031T724%2026Q752%2026%20776%2056T815%20138Q818%20149%20821%20151T837%20153Q857%20153%20857%20145Q857%20144%20853%20130Q845%20101%20831%2073T785%2017T716%20-10Q669%20-10%20648%2017T627%2073Q627%2092%20663%20193T700%20345Q700%20404%20656%20404H651Q565%20404%20506%20303L499%20291L466%20157Q433%2026%20428%2016Q415%20-11%20385%20-11Q372%20-11%20364%20-4T353%208T350%2018Q350%2029%20384%20161L420%20307Q423%20322%20423%20345Q423%20404%20379%20404H374Q288%20404%20229%20303L222%20291L189%20157Q156%2026%20151%2016Q138%20-11%20108%20-11Q95%20-11%2087%20-5T76%207T74%2017Q74%2030%20112%20181Q151%20335%20151%20342Q154%20357%20154%20369Q154%20405%20129%20405Q107%20405%2092%20377T69%20316T57%20280Q55%20278%2041%20278H27Q21%20284%2021%20287Z%22%3E%3C%2Fpath%3E%0A%3Cpath%20stroke-width%3D%221%22%20id%3D%22E1-MJMAIN-2217%22%20d%3D%22M229%20286Q216%20420%20216%20436Q216%20454%20240%20464Q241%20464%20245%20464T251%20465Q263%20464%20273%20456T283%20436Q283%20419%20277%20356T270%20286L328%20328Q384%20369%20389%20372T399%20375Q412%20375%20423%20365T435%20338Q435%20325%20425%20315Q420%20312%20357%20282T289%20250L355%20219L425%20184Q434%20175%20434%20161Q434%20146%20425%20136T401%20125Q393%20125%20383%20131T328%20171L270%20213Q283%2079%20283%2063Q283%2053%20276%2044T250%2035Q231%2035%20224%2044T216%2063Q216%2080%20222%20143T229%20213L171%20171Q115%20130%20110%20127Q106%20124%20100%20124Q87%20124%2076%20134T64%20161Q64%20166%2064%20169T67%20175T72%20181T81%20188T94%20195T113%20204T138%20215T170%20230T210%20250L74%20315Q65%20324%2065%20338Q65%20353%2074%20363T98%20374Q106%20374%20116%20368T171%20328L229%20286Z%22%3E%3C%2Fpath%3E%0A%3Cpath%20stroke-width%3D%221%22%20id%3D%22E1-MJMATHI-62%22%20d%3D%22M73%20647Q73%20657%2077%20670T89%20683Q90%20683%20161%20688T234%20694Q246%20694%20246%20685T212%20542Q204%20508%20195%20472T180%20418L176%20399Q176%20396%20182%20402Q231%20442%20283%20442Q345%20442%20383%20396T422%20280Q422%20169%20343%2079T173%20-11Q123%20-11%2082%2027T40%20150V159Q40%20180%2048%20217T97%20414Q147%20611%20147%20623T109%20637Q104%20637%20101%20637H96Q86%20637%2083%20637T76%20640T73%20647ZM336%20325V331Q336%20405%20275%20405Q258%20405%20240%20397T207%20376T181%20352T163%20330L157%20322L136%20236Q114%20150%20114%20114Q114%2066%20138%2042Q154%2026%20178%2026Q211%2026%20245%2058Q270%2081%20285%20114T318%20219Q336%20291%20336%20325Z%22%3E%3C%2Fpath%3E%0A%3Cpath%20stroke-width%3D%221%22%20id%3D%22E1-MJMATHI-65%22%20d%3D%22M39%20168Q39%20225%2058%20272T107%20350T174%20402T244%20433T307%20442H310Q355%20442%20388%20420T421%20355Q421%20265%20310%20237Q261%20224%20176%20223Q139%20223%20138%20221Q138%20219%20132%20186T125%20128Q125%2081%20146%2054T209%2026T302%2045T394%20111Q403%20121%20406%20121Q410%20121%20419%20112T429%2098T420%2082T390%2055T344%2024T281%20-1T205%20-11Q126%20-11%2083%2042T39%20168ZM373%20353Q367%20405%20305%20405Q272%20405%20244%20391T199%20357T170%20316T154%20280T149%20261Q149%20260%20169%20260Q282%20260%20327%20284T373%20353Z%22%3E%3C%2Fpath%3E%0A%3C%2Fdefs%3E%0A%3Cg%20stroke%3D%22currentColor%22%20fill%3D%22currentColor%22%20stroke-width%3D%220%22%20transform%3D%22matrix(1%200%200%20-1%200%200)%22%20aria-hidden%3D%22true%22%3E%0A%20%3Cuse%20xlink%3Ahref%3D%22%23E1-MJMATHI-6D%22%20x%3D%220%22%20y%3D%220%22%3E%3C%2Fuse%3E%0A%20%3Cuse%20xlink%3Ahref%3D%22%23E1-MJMAIN-2217%22%20x%3D%221100%22%20y%3D%220%22%3E%3C%2Fuse%3E%0A%3Cg%20transform%3D%22translate(1823%2C0)%22%3E%0A%20%3Cuse%20xlink%3Ahref%3D%22%23E1-MJMATHI-62%22%20x%3D%220%22%20y%3D%220%22%3E%3C%2Fuse%3E%0A%20%3Cuse%20transform%3D%22scale(0.707)%22%20xlink%3Ahref%3D%22%23E1-MJMATHI-65%22%20x%3D%22607%22%20y%3D%22583%22%3E%3C%2Fuse%3E%0A%3C%2Fg%3E%0A%3C%2Fg%3E%0A%3C%2Fsvg%3E#card=math&code=m%20%2A%20b%20%5E%20e&id=v9q0c)的形式，存储一个数值，`m`是小数部分，`b`是基数（通常是2），`e`是指数部分。这种形式是精度和数值范围的一种结合，可以表示非常大或者非常小的数。
使用`float`来声明浮点数变量。`float`类型占用4个字节（32位）（单精度浮点数），其中8位存放指数的值和符号，剩下的24位存放小数的值和符号。`float`类型至少能够提供（十进制的）6位有效数字，指数部分的范围为（十进制的）`-37`到`37`，即数值范围为![](https://cdn.nlark.com/yuque/__latex/496ebf8bfd434862e79e0a1c3e872177.svg#card=math&code=10%5E%7B-37%7D&id=HtzDG)到![](https://cdn.nlark.com/yuque/__latex/0ece8e664994c49c363856789b164641.svg#card=math&code=10%5E%7B37%7D&id=cRZgy)。
有时候，32位浮点数提供的精度或者数值范围还不够，C 语言又提供了另外两种更大的浮点数类型。

- `double`：占用8个字节（64位），至少提供13位有效数字（双精度浮点数）。
- `long double`：通常占用16个字节。

由于存在精度限制，浮点数只是一个近似值，它的计算是不精确的，比如 C 语言里面`0.1 + 0.2`并不等于`0.3`，而是有一个很小的误差。这是因为计算机的内部都是以二进制的形式来保存整数和浮点数，对于整数二进制可以很好的表示，但是二进制表示浮点数就会存在误差，两个二进制浮点数在一起运算之后得到的结果会根据数据类型的精度进行舍去多余位然后再转成十进制的浮点数。
# 布尔类型
C 语言原来并没有为布尔值单独设置一个类型，而是使用整数0表示伪，所有非零值表示真。
头文件`stdbool.h`定义了另一个类型别名`bool`，并且定义了true代表1、false代表0。只要加载这个头文件，就可以使用这几个关键字。
```c
#include <stdbool.h>

bool flag = false;
```
上面示例中，加载头文件`stdbool.h`以后，就可以使用`bool`定义布尔值类型，以及`false`和`true`表示真伪。
# 字面量类型
字面量（ilteral），指的是代码里面直接出现的值。
```c
int x = 123;
```
上面的代码中`x`是变量，`123`就是字面量。
编译时，字面量也会写入内存，因此编译器必须对字面量指定数据类型，就像必须为变量指定数据类型一样。
一般情况下，十进制整数字面量（比如`123`）会被编译器指定为`int`类型。如果一个数值比较大，超出了`int`能够表示的范围，编译器会将其指定为`long int`。如果数值超过了`long int`，会被指定为`unsigned long`。如果还不够大，就指定为`long long`或`unsigned long long`。这也就是为什么会出现溢出和编译时编译器提示的原因。
小数（比如3.14）会被指定为`double`类型。
# 字面量后缀
有时候，程序员希望为字面量指定一个不同的类型。比如，编译器将一个整数字面量指定为`int`类型，但是程序员希望将其指定为`long`类型，这时可以为该字面量加上后缀l或L，编译器就知道要把这个字面量的类型指定为`long`。
```c
int x = 123L;
```
总结一下，常用的字面量后缀有下面这些。

- f和F：`float`类型。
- l和L：对于整数是`long int`类型，对于小数是`long double`类型。
- ll和LL：`Long Long `类型，比如3LL。
- u和U：表示`unsigned int`，比如15U、0377U。

`u`还可以与其他整数后缀结合，放在前面或后面都可以，比如`10UL`、`10ULL`和`10LLU`都是合法的。
下面是一些示例：
```c
int           x = 1234;
long int      x = 1234L;
long long int x = 1234LL

unsigned int           x = 1234U;
unsigned long int      x = 1234UL;
unsigned long long int x = 1234ULL;

float x       = 3.14f;
double x      = 3.14;
long double x = 3.14L;
```
# 溢出
每一种数据类型都有数值范围，如果存放的数值超出了这个范围（小于最小值或大于最大值），需要更多的二进制位存储，就会发生溢出。大于最大值，叫做向上溢出（overflow）；小于最小值，叫做向下溢出（underflow）。
一般来说，编译器不会对溢出报错，会正常执行代码，但是会忽略多出来的二进制位，只保留剩下的位，这样往往会得到意想不到的结果。所以，应该避免溢出。
下面有个整型溢出的例子
```c
unsigned int ui = UINT_MAX;  // 4,294,967,295
ui++;
printf("ui = %u\n", ui); // 0
ui--;
printf("ui = %u\n", ui); // 4,294,967,295
```

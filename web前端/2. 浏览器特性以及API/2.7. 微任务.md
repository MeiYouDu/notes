# 简介

微任务(microtask)是一个短暂的函数，它会在javascript execution stack（js 执行栈）清空时被执行，微任务被程序或者函数创建，并在它们被执行之后再执行。在微任务执行结束之后，会将控制权交换给事件循环供用户使用脚本的运行环境（也就是说微任务执行期间会阻塞）。

这里的事件循环包括主程序的事件循环和存在于 web worker 中的事件循环。事件循环使给出的函数不会有影响其他脚本执行的风险，==也确保在这个微任务能在用户有机会对微任务产生的行为作出反应前运行==。

javascript 的`promise`和`mutation observe API`都是通过微任务队列运行回调，但是会有其他情况可以推迟微任务回调的运行直到当前事件循环执行执行结束。为了方便三方库、框架、补丁使用微任务，浏览器运行时支持了 `queueMicrotask`，支持主线程和 `Worker`线程。

# Task vs microtask

当我们调试程序或者想要解决跟任务和微任务执行顺序相关的问题时，了解 javascript 运行时的底层操作是非常有用的。

说起 javascript 的运行时底层操作，就不得不提 javascript 的设计背景。

javascript 本质上是一门单线程语言(single-threaded)，在那个时代这样设计是一个正确的选择，当时很少遇到多进程的计算机，而且当时需要 javascript 处理的代码量也是比较少的。

时过境迁，我们都知道现在的电脑基本都是多进程的，而且 JavaScript 也变成了目前世界上最受欢迎的语言之一。基于 javascript 开发了很多流行的应用程序，为了更好的支持，让 JavaScript 摆脱单线程语言的限制也变得迫在眉睫。

从web api 中的`timeout(settimeout)`和 `interval(setinterval)`开始，javascript 的运行环境——浏览器逐渐的提供了很多高级功能支持任务队列，和多线程应用程序，理解`queueMicrotask`有助于理解 JavaScript在规划和执行代码时的运行操作。

## javascript执行上下文（execution context）

当一个 javascript 的代码片段运行在一个执行上下文时，会有三种类型的代码可以创建新的执行上下文。

- 全局上下文是一个被创建用来执行我们的代码主要部分的执行上下文，这个上下文在函数作用域之外。
- 每个函数都具有自己的执行上下文。
- 使用 `eval `函数的时候也会创建一个新的执行上下文

每个上下文，原则上都是我们代码中的一个层级的作用域，当其中的一个代码片段被执行时会创新一个新的执行上下文，当代码执行完成这个上下文就会被销毁。

使用执行上下文来管理，每个程序和函数都有它自己的变量或其他对象。每个上下文都还回追踪它的下一行代码和其他的重要上下文操作信息（比如调用栈信息）。

==需要特别注意的是递归函数，这种函数有个可能产生多层级的调用，每次调用都会产生一个新的执行上下文。这样做的好处是javascript 运行时会通过上下文追踪递归层级和递归的返回值，但是也会导致更多的内存占用。（当递归层级达到一定限制，会导致调用栈逸出的问题）==

##  javascript运行时（run,javascript,run）

为了执行 javascript 代码，引擎维护了一组执行 javascript 代码的代理。==每个代理都由一组执行上下文、执行上下文栈、一个主线程、一组用来处理workers的其他线程、一个任务队列和一个微任务队列组成==。以上主线程之外的每个代理都是自己独有一个代理，主线程在有些浏览器中可能会共用一个。

下面来详细了解运行时

## 事件循环

每个代理都是被 `event loop`驱动的，==事件循环会收集用户产生的事件放入任务队列并执行回调函数。然后执行等待中的js 任务，然后执行等待中的微任务，然后在事件循环再次检查等待中的任务之前渲染和绘制页面==。

我们的应用程序的代码和浏览器用户界面运行在同一个线程里面，共享同一个事件循环。这就是主线程，它会运行网站的主要代码、还会接收和发送用户事件、渲染和绘制页面内容等。

事件循环，==驱动所有浏览器内跟用户交互有关的事情，更重要的是它负责调度和执行它线程内每一个代码片段。==（所有的用户交互都是由事件循环实现的）

**下面有三种事件循环**：

- window 事件循环，它可以驱动所有同源的windows。
- worker 事件循环，它是用来驱动worker 的，包括所有的类型的 worker，包括`web worker`、`shared worker`和`serivce worker`。Worker 被保存在一个或多个与“主”代码分开的代理中；浏览器可以对所有特定类型的工作者使用一个事件循环，也可以使用多个事件循环来处理它们。
- [worklet (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Worklet) 事件循环驱动运行 worklet 的代理。这包含了 [`Worklet` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Worklet)、[`AudioWorklet` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/AudioWorklet) 以及 [`PaintWorklet` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/PaintWorkletGlobalScope)。

多个同[源](https://developer.mozilla.org/zh-CN/docs/Glossary/Origin)窗口可能运行在相同的事件循环中，每个队列任务进入到事件循环中以便处理器能够轮流对它们进行处理。记住这里的网络术语“window”实际上指的是“用于运行网页内容的浏览器级容器”，包括实际的 window、标签页或者一个 frame。

在特定情况下，同源窗口之间共享事件循环，例如：

- 如果一个窗口打开了另一个窗口，它们可能会共享一个事件循环。
- 如果窗口是包含在 [`iframe`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe) 中的容器，则它可能会和包含它的窗口共享一个事件循环。
- 在多进程浏览器中多个窗口碰巧共享了同一个进程。

### 任务和微任务

一个任务指的遵循标准机制按照调度执行的任何 javascript 代码，如程序的初始化、事件触发的回调等。除了使用事件，你还可以使用 [`setTimeout()`](https://developer.mozilla.org/zh-CN/docs/Web/API/setTimeout) 或者 [`setInterval()`](https://developer.mozilla.org/zh-CN/docs/Web/API/setInterval) 来添加任务。

任务队列和微任务队列的区别：

- 当执行来自任务队列中的任务时，在每一次新的事件循环开始迭代的时候运行时都会执行队列中的每个任务。在每次迭代开始之后加入到队列中的任务需要*在下一次迭代开始之后才会被执行*。
- 每次当一个任务退出且执行上下文栈为空的时候，微任务队列中的每一个微任务会依次被执行。不同的是它会等到微任务队列为空才会停止执行——即使中途有微任务加入。换句话说，微任务可以添加新的微任务到队列中，这些新的微任务将在下一个任务开始运行之前，在当前事件循环迭代结束之前执行。

# 总结

## 为什么 javascript 是单线程的

考虑时代背景，javascript 被设计的出来的那个时代很少存在多核心计算机。dom 不可多线程操作，会导致渲染混乱。

## 事件循环是什么

事件循环是一个调度机制，负责管理不同类型任务的执行顺序。

1. 先执行同步代码。遇到 timer则交给 timer 线程处理（timer 如果定时是 0 秒，则直接放入任务队列），遇到 promise 则将 promise.then 的回调放入微任务队列。
2. 事件循环检查微任务队列，如果有任务则一次性全部放入执行栈执行。
3. 检查是是否需要更新页面，如果有的话则渲染。
4. 事件循环检查红任务队列，如果有任务则取出一个放入执行栈，然后回到第一步。

这里需要注意的是，每次事件循环中放入队列的宏任务都会再下一次循环开始时执行。而且一次只会执行一个。

# 简介

微任务(microtask)是一个短暂的函数，它会在javascript execution stack（js 执行栈）清空时被执行，微任务被程序或者函数创建，并在它们被执行之后再执行。在微任务执行结束之后，会将控制权交换给事件循环供用户使用脚本的运行环境（也就是说微任务执行期间会阻塞）。

这里的事件循环包括主程序的事件循环和存在于 web worker 中的事件循环。事件循环使给出的函数不会有影响其他脚本执行的风险，==也确保在这个微任务能在用户有机会对微任务产生的行为作出反应前运行==。

javascript 的`promise`和`mutation observe API`都是通过微任务队列运行回调，但是会有其他情况可以推迟微任务回调的运行直到当前事件循环执行执行结束。为了方便三方库、框架、补丁使用微任务，浏览器运行时支持了 `queueMicrotask`，支持主线程和 `Worker`线程。

# Task vs microtask

当我们调试程序或者想要解决跟任务和微任务执行顺序相关的问题时，了解 javascript 运行时的底层操作是非常有用的。

说起 javascript 的运行时底层操作，就不得不提 javascript 的设计背景。

javascript 本质上是一门单线程语言(single-threaded)，在那个时代这样设计是一个正确的选择，当时很少遇到多进程的计算机，而且当时需要 javascript 处理的代码量也是比较少的。

时过境迁，我们都知道现在的电脑基本都是多进程的，而且 JavaScript 也变成了目前世界上最受欢迎的语言之一。基于 javascript 开发了很多流行的应用程序，为了更好的支持，让 JavaScript 摆脱单线程语言的限制也变得迫在眉睫。

从web api 中的`timeout(settimeout)`和 `interval(setinterval)`开始，javascript 的运行环境——浏览器逐渐的提供了很多高级功能支持任务队列，和多线程应用程序，理解`queueMicrotask`有助于理解 JavaScript在规划和执行代码时的运行操作。

## javascript执行上下文（execution context）

当一个 javascript 的代码片段运行在一个执行上下文时，会有三种类型的代码可以创建新的执行上下文。

- 
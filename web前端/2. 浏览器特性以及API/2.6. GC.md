# 简介

在低级语言中，如 C 语言，需要手动的进行内存管理，如使用`malloc()`和`free()`方法。相反的，JavaScript 中会在创建对象时自动的分配内存，并在不再需要这个对象时自动释放内存（垃圾回收）。这种自动的垃圾回收会给开发者一种错觉：他们不需要关心内存管理。

# 内存生命周期

==无论是何种编程语言，内存生命周期都总是遵循下面这个流程：==

1. ==在我们需要的时候分配内存。==
2. ==使用分配到的内存（读，写）。==
3. ==当不再需要的时候释放掉这块内存。==

在所有的语言中，第二部分都是显式的（开发者自行管理），第一步和最后一步在低级语言中是显式的，但是在高级语言中（比如 JavaScript）是隐式的（引擎管理）。

## JavaScript 中的内存分配

### 值初始化

为了在分配内存时不影响程序，JavaScript将在值初始化声明时自动分配内存。

```javascript
const n = 123; // allocates memory for a number
const s = "azerty"; // allocates memory for a string

const o = {
  a: 1,
  b: null,
}; // allocates memory for an object and contained values

// (like object) allocates memory for the array and
// contained values
const a = [1, null, "abra"];

function f(a) {
  return a + 2;
} // allocates a function (which is a callable object)

// function expressions also allocate an object
someElement.addEventListener(
  "click",
  () => {
    someElement.style.backgroundColor = "blue";
  },
  false,
);
```

### 通过函数调用分配内存

比如一些函数的返回值是一个对象

```javascript
const d = new Date(); // allocates a Date object

const e = document.createElement("div"); // allocates a DOM element
```

比如一些函数的返回值会创建新的对象或者值

```javascript
const s = "azerty";
const s2 = s.substr(0, 3); // s2 is a new string
// Since strings are immutable values,
// JavaScript may decide to not allocate memory,
// but just store the [0, 3] range.

const a = ["ouais ouais", "nan nan"];
const a2 = ["generation", "nan nan"];
const a3 = a.concat(a2);
// new array with 4 elements being
// the concatenation of a and a2 elements.
```

### 使用值

在分配的内存中进行读写操作，这些操作包含不限于变量或对象属性读写，甚至给函数传参。

### 内存释放

内存管理中最主要的问题发生在这一阶段，这一阶段最困难的是确定何时不在需要这块内存。

低级语言中需要开发者手动确定程序在何时不在需要这块内存并且释放它。

高级语言中，如 JavaScript，利用一种称为垃圾回收（garbage collection as GC）的自动内存管理机制，垃圾回收的目的是监视内存分配和确定一块内存何时不在被需要并回收它。这只能是一个近似的过程，因为要知道是否仍然需要某块内存是[无法判定的](http://en.wikipedia.org/wiki/Decidability_(logic))（无法通过某种算法解决）。

# 垃圾收集

综上所述，上文说了一个问题—被分配的内存何时不再需要是无法确认的。因此，内存回收只是这些问题的一个有限解决方案。这个章节 会解释主要的垃圾回收算法和他们各自的限制。

## 引用

“引用”是垃圾回收算法依赖的一个主要概念。==在内存管理的上下文里，一个对象具有另一个对象的访问入口（无论是显式还是隐式）就称前者引用了后者==。举个例子， JavaScript 对象具有隐式引用如它的 `prototype`，还有显式引用如它的属性值。这里的对象不仅特指 JavaScript 对象，还包含函数作用域（或全局词法作用域）。

## 引用计数垃圾回收

<!--注意：并不是所有的现代浏览器都使用引用计数垃圾回收机制-->

这是最简单的垃圾回收算法，算法通过这个对象是否还被其他的对象引用来判断这个对象是否还被需要，如果一个对象没有被任何对象引用，则会被认为是垃圾或者可回收♻️。

```javascript
let x = {
  a: {
    b: 2,
  },
};
// 2 objects are created. One is referenced by the other as one of its properties.
// The other is referenced by virtue of being assigned to the 'x' variable.
// Obviously, none can be garbage-collected.

let y = x;
// The 'y' variable is the second thing that has a reference to the object.

x = 1;
// Now, the object that was originally in 'x' has a unique reference
// embodied by the 'y' variable.

let z = y.a;
// Reference to 'a' property of the object.
// This object now has 2 references: one as a property,
// the other as the 'z' variable.

y = "mozilla";
// The object that was originally in 'x' has now zero
// references to it. It can be garbage-collected.
// However its 'a' property is still referenced by
// the 'z' variable, so it cannot be freed.

z = null;
// The 'a' property of the object originally in x
// has zero references to it. It can be garbage collected.
```

但是引用计数算法也会有一些限制，比如在下面这个例子中，我们在一个函数中创建了两个对象，并且给对象的属性分别赋值给对方，这样就形成了一个==嵌套引用==。当函数调用后，这个两个对象都会离开函数作用域，因此这两个对象也就不再需要了且为它们分配的内存也应该释放掉，但是引用计数算法却不认为需要回收它们，因为它们引用了彼此。这导致它们没有被标记为可回收，也就导致了内存泄漏。

## 标记清除算法（mark-and-sweep-algorithm）

这个通过对象是否可以被访问来判断“对象是否不再被需要”。

这个算法假设一组叫做根 `root`的对象（JavaScript 里面是全局对象），算法将周期性的从这些跟对象查找所有被他们引用的对象。就这样垃圾收集器将查找所有可访问的对象并收集所有不可访问的对象。

这个算法是前面引用计数算法的改进，他能够处理循环引用的情况，因为0 引用的对象实际上是不可访问的。

目前，所有现代引擎都配备了标记-清除垃圾收集器。过去几年JavaScript垃圾收集(分代/增量/并发/并行垃圾收集)领域的所有改进都是对该算法的实现改进，但不是对垃圾收集算法本身的改进，也不是修改“不再需要对象”的定义。

然而，还是不能手动管理内存。手动的管理内存有时是很方便的。而且现在如果想释放内存，需要显式的让一个对象变得不可访问。==按照官方的说法从今到未来都不可能编程式的触发垃圾回收。==

# 配置引擎的内存模型

JavaScript引擎通常提供暴露内存模型的标志。例如，Node.js提供了额外的选项和工具，这些选项和工具暴露了V8的底层机制，用于配置和调试内存问题。这种配置在浏览器中可能不可用，对于网页(通过HTTP头等)更是如此。

通过这个 flag 来配置最大的可用堆内存

```bash
node --max-old-space-size=6000 index.js
```

通过下面这个命令来暴露垃圾收集来调试解决内存问题

```bash
node --expose-gc --inspect index.js
```

# 数据结构辅助内存管理


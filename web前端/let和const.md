# let
存在暂时死区。
没有变量提升。
受到块级作用域得约束。
可以在块级作用域中声明函数。
不能重复声明。
# Const
申明一个只读常量，一旦声明就不可以改变。
只申明不赋值就会报错。
受到块级作用域的约束。
没有变量提升。
存在暂时性死区。
const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。
# 声明对象的六种方法

- var
- function
- let
- const
- class
- import
# 顶层对象的属性
顶层对象，在浏览器环境指的是window对象，node中测试global对象。
es5中顶层对象的属性与全局变量是等价的。
es6中为了保持兼容性，var和function命令声明的全局变量依旧是顶层对象的属性；let，const，class命令声明的全局变量，不属于顶层属性。
# globalThis对象
JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。

- 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。
- 浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。
- Node 里面，顶层对象是global，但其他环境都不支持。
- 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。
- 全局环境中，this会返回顶层对象。但是，Node.js 模块中this返回的是当前模块，ES6 模块中this返回的是undefined。
- 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。
- 不管是严格模式，还是普通模式，new Function('return this')()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用。

# 针对不同环境的性能优化

感觉CICD的性能优化跟`runner`的环境息息相关。比如docker镜像`runner`和`shell runner`就有非常大的区别。

## docker镜像

docker镜像作为runner的时候行为有以下特点

1. 每个job都会移除未缓存的内容
2. 每个job都会从新拉取代码
3. docker镜像环境每次都需要初始化
4. 无法使用如pnpm的全局缓存，除非显式的配置CI脚本去缓存

## shell runner

1. `CI script`所具有的能力依赖于`runner`全局安装的命令行工具。
2. 可以直接使用如pnpm的全局缓存能力。

# 最佳实践

## docker环境

### pnpm

On GitLab, you can use pnpm for installing and caching your dependencies like so (belongs in `.gitlab-ci.yml`):

```yaml
stages:
  - build

build:
  stage: build
  image: node:18.17.1
  before_script:
    - npm install --global corepack@latest
    - corepack enable
    - corepack prepare pnpm@latest-10 --activate
    - pnpm config set store-dir .pnpm-store
  script:
    - pnpm install # install dependencies
  cache:
    key:
      files:
        - pnpm-lock.yaml
    paths:
      - .pnpm-store
```

从上面官方推荐的做法来看是推荐我们缓存store，而不是node_modules本身，毕竟pnpm的node_modules都是硬链接，在docker环境中缓存了也没有什么意义，缓存store每次安装直接快速硬链接并还原

### build cache

比如webpack，eslint，babel等工具的缓存，通常都在当前工程目录的node_modules/.cache这个路径下，所以通过下面这个配置对构建系统的缓存也进行CI缓存

```yaml
cache:
    key:
      files:
        - pnpm-lock.yaml
    paths:
      - node_modules/.cache/
    policy: pull-push
```

## shell环境

1. ==取决于服务器的性能，通常来说是不如 share runner 的性能，性能很差的话甚至不用缓存，因为缓存压缩和提取非常耗费性能，所以在这种环境可以不用 CI 的缓存，并且配置不清除 `node_modules`，这样就会使用工程如 webpack 本身的缓存==
2. 通过配置可以让shell环境的 node_modules 并不会被清除，所以安装一次就好了。
3. 环境不分离。

==下面是一段实际项目中的 CI 配置（核心是利用 runner 环境的一些特性来优化 CI 效率，比如 CI cache）==

```yaml
variables:
    FF_USE_FASTZIP: 1
    # 对产物使用快速压缩，结果是较大的归档
    ARTIFACT_COMPRESSION_LEVEL: "fast"
    # 对缓存不使用压缩
    CACHE_COMPRESSION_LEVEL: "fast"
    NODE_VERSION: "20.19.4"
    # 确保 corepack 可用（node:lts 已包含 corepack）
    PNPM_VERSION: "10.14.0"
    # 本地 pnpm store
    PNPM_STORE_DIR: "$CI_PROJECT_DIR/.pnpm-store"
    YARN_VERSION: "1.22.22"
    YARN_CACHE_FOLDER: "$CI_PROJECT_DIR/.yarn/cache"
    # 缓存过期时间
    CACHE_EXPIRE: "7d"
    # artifact 过期时间
    ARTIFACT_EXPIRE: "1d"
    # APP_NAME: "anno_3d_mark"
    DIST_ZIP_FILE_NAME: "dist.tar.gz"
    DIST_DIR: "$CI_PROJECT_DIR/dist/"
    GIT_CLEAN_FLAGS: -ffd
    GIT_DEPTH: 0
    GIT_STRATEGY: fetch

stages:
    - prepare
    - install
    - test
    - build
    - package
    - deploy


.prepare-yarn: &prepare-yarn |
  # npx corepack enable
  # npx corepack prepare yarn@${YARN_VERSION} --activate
  node -v
  yarn -v

.prepare-pnpm: &prepare-pnpm |
  nvm use $NODE_VERSION
  # npx corepack enable
  # npx corepack prepare pnpm@${PNPM_VERSION} --activate
  node -v
  pnpm -v

# 常规规则
.rules-standard: &rules-standard
  rules:
    - if: $CI_PIPELINE_SOURCE == "push"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - when: never

# 匹配开发分支
.rules-test: &rules-test
  rules:
    - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH == "release-3d"
    - when: never

# 匹配发布分支
.rules-release: &rules-release
  rules:
    - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH == "master"
    - when: never

prepare:
    stage: prepare
    extends:
      - .rules-standard
    script:
        - echo "Prepare stage"
        - echo "CI_PROJECT_DIR=$CI_PROJECT_DIR"
    rules:
        - if: $CI_PIPELINE_SOURCE

install:
    stage: install
    extends:
        - .rules-standard
    needs:
      - prepare
    before_script:
        - *prepare-pnpm
        - echo "CI_PROJECT_DIR=$CI_PROJECT_DIR"
    script:
        - echo "Install stage"
        - |
          if [ -f pnpm-lock.yaml ]; then
            echo "Using pnpm (lockfile detected)"
            pnpm install --frozen-lockfile
          fi


test:
    stage: test
    extends:
        - .rules-standard
    needs:
        - install
    before_script:
      - *prepare-pnpm
      - echo "CI_PROJECT_DIR=$CI_PROJECT_DIR"
    script:
        - echo "Test step"
        - npx eslint -c ./eslint.config.mjs --cache ./src

build-for-test:
    stage: build
    extends:
      - .rules-test
    needs:
      - install
    before_script:
      - *prepare-pnpm
      - echo "CI_PROJECT_DIR=$CI_PROJECT_DIR"
    script:
      - echo "Build step"
      - |
        if [ -f pnpm-lock.yaml ]
        then
          pnpm -s build
        fi
      - |
        if [ -d $DIST_DIR ]
        then
          echo "Create zip file"
          tar -zcf $DEPLOY_PACKAGE_PATH/$APP_NAME-test-${CI_BUILD_REF:0:8}.tar.gz -C $DIST_DIR .
        else
          echo "no project"
        fi
    artifacts:
      name: "${APP_NAME}-${CI_COMMIT_SHORT_SHA}"
      paths:
        - $DIST_DIR
      expire_in: 1d
      when: on_success
    cache:
      key:
        files:
          - pnpm-lock.yaml
      paths:
        - node_modules/.cache/
      policy: pull-push

build-for-release:
    stage: build
    extends:
      - .rules-release
    needs:
      - install
    before_script:
      - *prepare-pnpm
      - echo "CI_PROJECT_DIR=$CI_PROJECT_DIR"
    script:
      - echo "Build step"
      - |
        if [ -f pnpm-lock.yaml ]
        then
          pnpm -s build
        fi
      - |
        if [ -d $DIST_DIR ]
        then
          echo "Create zip file"
          mkdir $DIST_DIR/annocloud/
          mv $DIST_DIR/static $DIST_DIR/annocloud/
          tar -zcf $DEPLOY_PACKAGE_PATH/$APP_NAME-${CI_BUILD_REF:0:8}.tar.gz -C $DIST_DIR .
        else
          echo "no project"
        fi
    artifacts:
      name: "${APP_NAME}-${CI_COMMIT_SHORT_SHA}"
      paths:
        - $DIST_DIR
      expire_in: 1d
      when: on_success
    cache:
      key:
        files:
          - pnpm-lock.yaml
      paths:
        - node_modules/.cache/
      policy: pull-push

package-for-test-8200:
    stage: package
    extends: .rules-test
    needs:
        - build-for-test
    script:
        - cd $SHELL_PATH
        - sh scp-test.ssh 8200

#package-for-test-8300:
#    stage: package
#    extends: .rules-test
#    needs:
#      - build-for-test
#    script:
#        - cd $SHELL_PATH
#        - sh scp-test.ssh 8300

package-for-release:
    stage: package
    extends: .rules-release
    needs:
      - build-for-release
    script:
        - cd $SHELL_PATH
        - sh scp-prod.ssh

deploy-to-test-8200:
    stage: deploy
    extends: .rules-test
    needs:
      - package-for-test-8200
    script:
        - cd $SHELL_PATH
        - sh deploy-test.ssh 8200

#deploy-to-test-8300:
#    stage: deploy
#    extends: .rules-test
#    needs:
#      - package-for-test-8300
#    script:
#        - cd $SHELL_PATH
#        - sh deploy-test.ssh 8300

deploy-to-release:
    stage: deploy
    extends: .rules-release
    needs:
      - package-for-release
    #    before_script:
    #      - formatted_timestamp=$(date --date="${CI_COMMIT_TIMESTAMP}" +"%Y%m%d%H%M")
    #      - TAG_NAME="v$formatted_timestamp.${CI_BUILD_REF:0:8}"
    #      - echo -e " ci $CI_SERVER_HOST/$CI_PROJECT_PATH.git"
    #      - git tag -a $TAG_NAME -m "$CI_COMMIT_MESSAGE" ; git push http://root:glpat-XZ1sdqEKVs3fNHc2ptG_@$CI_SERVER_HOST/$CI_PROJECT_PATH.git tag $TAG_NAME
    #      - echo -e "新增版本号:$tagName"
    script:
        - cd $SHELL_PATH
        - sh deploy-prod.ssh
```


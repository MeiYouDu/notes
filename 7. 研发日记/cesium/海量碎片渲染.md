# 问题
有些需求可能会要缓存海量的过程数据，比如卫星轨道数据，碎片轨道数据。当有1200个碎片的时候，步长是10秒，让服务端计算一天的碎片轨道数据。返回客户端之后数据一共有3200MB左右。如果客户端的物理机配置不够好，可能会导致浏览器内存溢出（out of memory）。
# 需求分析

- 浏览器主线程里面如果缓存大量的数据会导致内存溢出。
- 需要快速的缓存和获取数据。
- 需支持海量数据的缓存（目前可能需要3200MB），如果是10万个卫星水片计算出来的数据，预估可以达到274999MB，也就差不多是269GB，这个数据量太大了。
# 2022-05-18
目前有两个方案
## indexDb缓存
客户端数据库缓存，首先indexdb的容量可以达到50%硬盘空间大小，大小可以满足需求，但是不知道数据量大的时候性能怎么样。目前还在爬坑。
这个方案已经放弃了**原因：**

- 首先indexdb可以缓存海量的数据，他的空间足够大，但是速度很慢。
- 当我尝试存入6w条数据的时候，在我的mac上存了15秒（因为我的是固态硬盘），但是在内网的台式机上（机械硬盘）。存了快两分钟。
### 结论
这个客户端数据库适合永久保存大量数据，但是不适合瞬时读写海量数据，如果对读写速率又非常高的要求这个技术路线不太适合。
## redis缓存
服务端通过redis缓存，redis性能非常好，但是需要客户端向服务端频繁的发器http请求，可能会导致数据更新不及时。这个路线暂时停滞。
### 结论
这个方案感觉也不太好，虽然redis性能非常好，但是因为需要客户端和服务端进行通信。感觉也会存在性能问题，而且这个方法也只是在局域网可行，互联网通信肯定效率更低。
# 2022-05-23
为了解决需求分析中的这三个需求。

- 如果碎片轨道是一秒钟一个点（步长是1秒），数据量太大了，10万个碎片可以产生269GB的数据，如果是60秒一个点甚至120秒一个点，粗略计算，数据量会减少60倍/120倍，那么10万碎片的总数据量就是4.48GB/2.24GB，这样也不会影响绘制的效果
- 因为需要快速缓存和获取数据，尤其是快速缓存数据，我觉得这个事情应该是发生在内存上，而不是硬盘上，硬盘io还是太慢了。所以还是决定在内存里缓存碎片轨道数据。
- 因为页面主线程的缓存太的数据会导致内存溢出，同时也会影响性能。所以需要通过别的线程来减少主线程的压力，这个时候就可以考虑使用webworker了。在各个子线程里面缓存数据，主线程需要的时候从各个子线程里面获取。
# 2022-06-02
主线程和子线程之间的通信如果很频繁的话会影响性能。但是这个功能需要在每当时间产生变化的时候就通知子线程获取数据。解决通信的性能问题可以利用worker提供的一个api，通过转移buffer的上下文来实现。这样效率会非常高，但是会涉及json和buffer之间的相互转化。但当json非常巨大的时候，json和buffer以及buffer和json相互转化的过程也会消耗很多性能。目前的做法是主线程to子线程通过buffer（发送信号）。子线程to主线程通过js对象（海量数据），这样通信造成的性能问题解决了。
解决了通信问题又新的问题，更新点位置的时候，性能也会有问题。目前的思路是采用手动请求下一帧，控制每次更新的时间为10ms，然后没更新完一组再请求下一帧数据。
# 2022-06-07
找到了一个解决方案[链接](https://community.cesium.com/t/27-5000-how-do-i-load-all-the-satellite-debris-data-tle-into-cesium/17355)，这是社区里面讨论的一种实现方法，通过`satellitejs`这个库在浏览器端计算碎片位置。这样避免了数据量太的问题（不用保存那么多的数据），同时可以有非常好的性能（可以用客户端多个线程计算）。
# 2022-06-16复盘
目前基本实现海量点渲染和更新。
## 思路
客户端根据cesium的时间实时计算碎片位置，然后渲染或更新点位置。
## 遇到的问题
### 计算量
#### 描述
客户端计算海量碎片轨道是非常耗费性能的，如果在一个线程里面计算并渲染，那肯定会导致掉帧
#### 方案
考虑开启一个子线程来负责计算。
### 线程通信效率
#### 描述
因为帧的更新速度是非常快的，比如60帧，那么每秒钟要更新60次，每次16ms。也就是说我们每16ms就要完成一次线程通信。如果还是传递普通的字符串、对象、数组，会导致渲染的帧率降低。这是因为postmessage方法为了保证线程安全在发送数据的时候会运行一个[**结构化克隆算法**](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm)，这也就导致传递的数据量太大或者调用的频率太高时会吃掉太多的性能。
#### 方案
浏览器的多线程是通过[webWorker](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API)实现的，worker提供了一个高性能的线程通信方式。[postmessage()](https://developer.mozilla.org/zh-CN/docs/Web/API/Worker/postMessage)接受两个参数，第一个参数`message`是需要传递的信息，第二个参数`transferList`用来传递所有权。用这个方式效率会有明显的提升。
### 海量点渲染
#### 描述
通过entities增加点效率非常低，甚至导致浏览器直接卡死。
#### 方案
cesium提供了一个点集合的api[pointPrimitiveCollection](https://cesium.com/learn/cesiumjs/ref-doc/PointPrimitiveCollection.html?classFilter=pointprimitive)，性能比高的多。
### 时间倍速导致帧率降低
#### 描述
在ceisum中调整时间倍速会导致计算过于频繁。
#### 方案
实现一个截流，降低调用频次，但是会带来**数据丢失的问题**，而且这个问题会随着倍速的提高而提高。但是为了解决性能问题，不得不采用这个折中的方案。
# 做的更好
[一个国外网站的例子](https://celestrak.com/cesium/orbit-viz.php?tle=/pub/TLE/catalog.txt&satcat=/pub/satcat.txt&referenceFrame=1)，这个例子使用了同样的算法，且卫星数据也是一样的，但是这个例子的效率非常之高，可以用丝滑来形容。
本着对技术的追求以及对公司技术栈的积累，我觉得有必要尝试实现一下类似的效果。
## 存在的问题
_以下问题提供的方案都只停留在思路上，没有真正实现过。_
### 客户端轨道算法
#### 描述
因为通常算法都是CPP实现的，所以客户端很难集成。
#### 方案
[webAssembly](https://developer.mozilla.org/zh-CN/docs/WebAssembly)，这个webapi提供了客户端运行CPP算法的可能性。
### 渲染效率
#### 描述
经过[2022-06-16复盘](#w38HU)，已经做了很多常规的渲染优化。但是还是达不到例子中所展示的渲染效率，是时候考虑换个思路了。
#### 方案
通过材质直接渲染，充分利用gpu加速。

